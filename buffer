printAddress :: Person -> IO ()
printAddress Person{..} = do
    putStrT personFirstNames >> putSep
    putStrT personLastName >> putSep
    putStrT personAddress >> putSep
    putStrT personZipcode >> putSep
    putStrT personCity
    putStrLn ""
  where
    putSep = putStr ";"

is2016 :: Person -> Bool
is2016 p = personHasTag (Tag "2015-2016") p && (not . T.null) (personAddress p)

putStrT = putStr . T.unpack

match :: Additional -> Person -> Bool
match a p = aFirst a `T.isPrefixOf` personFirstNames p &&
            (T.strip (aFamily a) == T.strip (personLastName p) ||
                (("os ." <> T.strip (aFamily a)) `T.isPrefixOf` T.strip (personLastName p)) ||
                ((T.strip (aFamily a) <> " ") `T.isPrefixOf` T.strip (personLastName p)))

printAdditional :: Additional -> IO ()
printAdditional (Additional f l ts) =
    putStrLn . T.unpack $ f <> "\t" <> l <> "\t" <> T.intercalate "," (fmap getTag . Set.toList . getTags $ ts)

backport :: Vector Additional -> Vector Person -> (Vector Additional, Vector Person)
backport add ps = execState (traverse_ f $ V.filter additionalHasTags add) (V.empty, ps)
  where
    f :: Additional -> State (Vector Additional, Vector Person) ()
    f a = case findVectorLens (match a) ps of
              Nothing -> _1 %= (<> V.singleton a)
              Just l  -> _2 . cloneLens l . personTags %= (<> aTags a)

memberToAdditional :: Vector Person -> Vector Additional
memberToAdditional = V.map toAdditional . V.filter hasTags
  where
    hasTags p = tagsLength (p ^. personTags) /= 0
    toAdditional p = Additional (personFirstNames p) (personLastName p) (p ^. personTags)


data Additional = Additional
    { aFirst  :: !Text
    , aFamily :: !Text
    , aTags   :: !Tags
    }
    deriving (Eq, Show)

additionalHasTags :: Additional -> Bool
additionalHasTags = not . Set.null . getTags . aTags

instance A.FromJSON Additional where
    parseJSON = A.withObject "Additional" $ \obj ->
        Additional <$> obj A..: "first"
                   <*> obj A..: "family"
                   <*> obj A..: "tags"

findVectorLens :: forall a. (a -> Bool) -> Vector a -> Maybe (ALens' (Vector a) a)
findVectorLens p vs = l . getFirst <$> getOption (ifoldMapOf folded p' vs)
  where
    l :: Int -> ALens' (Vector a) a
    l i =  lens (\v -> v V.! i) (\v x -> v V.// [(i, x)])

    p' :: Int -> a -> Option (First Int)
    p' i x | p x       = Option . Just . First $ i
           | otherwise = Option Nothing
